#!/bin/bash
#Author:Mario Franco-Munoz
#Script Name: matrix (assignment 1; CS344)
#Due Date: 4/23/2018

#temp file

TMP=TMP$$

#trap for delting files upon exit
#source/reference:
# https://stackoverflow.com/questions/687014/removing-created-temp-files-in-unexpected-bash-exit
trap "rm -f $TMP*" EXIT
trap "rm -f $TMP*; exit 1" INT HUP TERM

#function: dims
#description: displays the dimensions of the input matrix "rows columns"
#input: file containing space delimited columns
#output: dimensions of input matrix "rows columns"
#source/reference:
#https://stackoverflow.com/questions/8629330/unix-count-of-columns-in-file
dims() {
	

	#create temporary file and load in contents of argument to temp file
	inputFile="20TMP$$"
	cat $1 >$inputFile
	
	#prints the dimensions of the array using wc (word count) and head
	read -r line < $inputFile
	printf "`wc -l < $inputFile` `head -1 $inputFile | tr '|' ' ' | wc -w`\n"
	rm -f "$inputFile"
}

#function: transpose
#description: reflects the elements along the diagonal
#input: M x N matrix in space delimited format M = rows, N = cols
#output: display (in I/O) inverted matrix. contents of input file changed to inverted matrix
#source/reference: Ryan Gambord's contributions to slack were key to understanding this problem
#cut portion in particular.
transpose() {

	inputFile2="10TMP$$"
	cat $1 >$inputFile2
	
	#use "head -n 1" to parse each line by line 
	row=$(head -n 1 $inputFile2 | wc -w)
	
	#cut and paste values from row to column using paste -s to tab delimit	 
	for i in $(seq 1 $row)
	do
		cut -f"$i" $inputFile2 | paste -s
	done
	
	rm -f "$inputFile2"

}

#function: mean
#description: takes an M x N matrix and returns a 1 x N row vector, where first element is the
# mean of column one, the second is the mean of column two etc.
#input:M x N matrix in space delimted format M = rows, N = cols
#output: 1 x N matrix with the average of each column
mean() {
	
	inputFile3="TMP$$"
	intermed="intermed$$"
	tempOutput="tmpOut$$"
	finalOutput="finOut$$"
	#cat $1 >"$inputFile3"

	transpose $1 > "$intermed"

	chmod u+rwx $intermed
	touch $tempOutput
	chmod u+rwx $tempOutput	

	echo $intermed | while read line
	
	do
	sum=0
	count=0
	avg=0
	abs=0
		for i in $line
		do
			sum=$((sum + i))
			count=$((count += 1))
		
		done

		#check to see if sum was negative	
		if [ "$sum" -lt 0 ]
		then
			abs=0
		else
			abs=1
		fi

		#calculate and  rounded average (as per assignment notes)
		avg=$(( (sum + (count / 2) * (abs * 2 - 1)) / count))
		
		echo "$avg" >> "$tempOutput"
 				

	done < $intermed
	
		
	#transpose results via temporary  placeholder file
	#so we don't have to deal with that annoying trailing \t character
	transpose "$tempOutput" > "$finalOutput"
	cat "$finalOutput"
	
	#remove temporary files
	rm -f "$tempOutput"
	rm -f "$finalOutput"		
	rm -f "$intermed"
}

#function: add
#description: adds two matrices if their dimensions match
#input:two files containing matricies of the same dimensions
#output:single matrix that is the sum of the two input matricies
add() {
	sumOut="specialTMP$$"
	temp="1TMP$$"
	tempCheck1="2TMP$$"
	tempCheck2="3TMP$$"
	left="4TMP$$"
	right="5TMP$$"
	xfer="6TMP$$"
	xfer2="7TMP$$"

	touch $sumOut
	chmod u+rwx $sumOut

	tempCheck1="$(dims $1)"
	tempCheck2="$(dims $2)"

	#echo "$tempCheck2"

	rowsA=$(cut -d " " -f1 <<< "$tempCheck1")
	rowsB=$(cut -d " " -f1 <<< "$tempCheck2")
	colsA=$(cut -d " " -f2 <<< "$tempCheck1")
	colsB=$(cut -d " " -f2 <<< "$tempCheck2")		


	#check to see if input matricies were valid
	errorMessage3=("Input matricies are not of the same dimensions.")
	if [[ $rowsA != $rowsB ]] || [[ $colsA != $colsB ]]
	then
		echo $errorMessage3 >&2
		exit 1
	fi


	  

	#add matrix A and B
	rowTracker=0
	sum=0
	#touch "$xfer"
	#touch "$xfer2"
	#chmod u+rwx $xfer
	#chmod u+rwx $xfer2
	#cat "$1" > "$xfer"
	#cat "$2" > "$xfer2"
	#cat $xfer
	
	#while
	#	read $1_line <&3;
	#	read $2_line <&4;
	#do
	for ((k=1; k<=$rowsA; k++))
	do
		rowTracker=$((rowTracker + 1))
		for ((i=1; i<=$colsA; i++))
		do
			#strip off the columns
			cut -f"$i" $1 > "$left"
			cut -f"$i" $2 > "$right"

			#strip down to the individual number
			head -n"$rowTracker" $left > "$temp"
			A=$(tail -n 1 $temp)
			
			head -n"$rowTracker" $right > "$temp"
			B=$(tail -n 1 $temp)
			
			
			#add summed value to output matrix
			sum=$((A + B))
			echo -ne "$sum" >> "$sumOut"
			
			
			#check if adding a tab character is applicable
			if [[ "$i" < "$colsA" ]]
			then
				echo -ne "\t" >> "$sumOut"
			fi
		done


		#check to see if rowTracking variable needs to be reset
		if [[ "$rowTracker" == "$rowsA" ]]
		then
			rowTracker=0
		fi
		
		#append newline character
		echo -ne "\n" >> "$sumOut"
		
	#done 3<$1 4<$2
	done
	
	cat "$sumOut"

	rm -f "$sumOut"
	rm -f "$tempCheck1"
	rm -f "$tempCheck2"
	rm -f "$left"
	rm -f "$right"
	rm -f "$temp"
	rm -f "$xfer"
	rm -f "$xfer2"
}


#function: multiply
#description:
#input:
#output:







#error messages
errorMessage1=("Incorrect number of arguments")
errorMessage2=("Bad command")

#check for incorrect number of arguments
#if [ "$#" -gt 2 ] || [ "$#" -lt 1 ];
#then
#	echo "$errorMessage1" >&2
#	exit 1
#fi

#check for empty arguments
#if [[ $# < 1 ]]
#then
	#echo "$errorMessage1">&2
	#exit 1
#fi


#"MAIN" SECTION

#$1 "${@:2}"



#run dims
if [[ $1 == "dims" ]] #&& [[ "$#" == "1" ]] 
then
	if [[ "$#" > "2" ]] || [[ "$#" < "1" ]]	
	then
		echo $errorMessage1 >&2
		exit 1
	fi
	dims "$2"
#run transpose
elif [[ $1 == "transpose" ]]
then
	transpose "$2"

#run mean
elif [[ $1 == "mean" ]]
then
	mean "$2"

#run add
elif [[ $1 == "add" ]]
then
	if [[ "$#" > 3 ]] || [[ "$#" < 3 ]]
	then
		echo $errorMessage1 >&2
		exit 1
	fi
	add "$2" "$3"

else
	echo "$errorMessage2">&2
	exit 1	
fi




